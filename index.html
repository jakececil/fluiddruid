<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fluid Dynamics Visualizer ‚Äî Faster Color Cycle</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#11161f; --ink:#cde6ff; --accent:#72f; --accent2:#0ff;
      --muted:#7e8aa2; --good:#39d353; --warn:#ffb020; --bad:#ff5470;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 20% 0%, #121826, #0b0f14 40% 100%);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif}
    #wrap{display:grid;grid-template-columns: 320px 1fr; grid-template-rows: 100vh; gap:0}
    #ui{background:linear-gradient(180deg,rgba(17,22,31,.95),rgba(17,22,31,.8));backdrop-filter: blur(8px);
         border-right:1px solid rgba(255,255,255,.06); padding:16px 14px 18px 16px; overflow:auto}
    #title{font-weight:800; letter-spacing:.5px; font-size:18px; margin:6px 0 12px}
    .sub{color:var(--muted); font-size:12px; margin-top:-6px; margin-bottom:12px}
    .row{margin:10px 0 14px}
    .row label{display:flex; align-items:center; justify-content:space-between; gap:10px; font-size:13px; color:#c7d3ea}
    .row input[type="range"]{width:100%}
    .row input[type="color"]{width:100%; height:36px; border:none; background:#0000}
    .row .val{font-variant-numeric:tabular-nums; color:#a9b7d9; min-width:70px; text-align:right}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
    .toggle{display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none; font-size:13px}
    .toggle input{appearance:none; width:36px; height:22px; background:#2b3344; border-radius:999px; position:relative; outline:none; transition:.2s}
    .toggle input:checked{background:linear-gradient(90deg, var(--accent), var(--accent2))}
    .toggle input::after{content:""; position:absolute; top:3px; left:3px; width:16px; height:16px; background:#fff; border-radius:50%; transition:.2s}
    .toggle input:checked::after{left:17px}
    button{background:#1b2333; color:#cde6ff; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px 10px; font-weight:600; cursor:pointer}
    button:hover{border-color:rgba(255,255,255,.2); box-shadow:0 0 0 2px rgba(114,34,255,.15)}
    #canvasWrap{position:relative; height:100vh; overflow:hidden}
    canvas{display:block; width:100%; height:100%}
    #hud{position:absolute; top:10px; left:10px; font-size:12px; color:#b9c6e4; background:rgba(10,14,22,.4); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.08)}
    #footer{font-size:11px; color:#8aa0c8; margin-top:10px;}
    .row .group{display:flex; gap:8px}
    .row .group > *{flex:1}
    .preset{display:flex; flex-wrap:wrap; gap:8px; margin-top:6px}
    .preset button{padding:6px 8px; font-size:12px}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; background:#0e1421; border:1px solid rgba(255,255,255,.08); padding:2px 6px; border-radius:6px}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="ui">
      <div id="title">üåà Fluid Dynamics Visualizer</div>
      <div class="sub">Click + drag to paint dye & add force. Right-click (or ‚å•/Alt) to add suction. Hold <span class="kbd">Shift</span> for big brush. Resize window to scale.</div>

      <div class="row">
        <label>Resolution <span class="val"><span id="nDisplay"></span> √ó <span id="nDisplayY"></span></span></label>
        <input id="n" type="range" min="48" max="196" step="4" value="128">
      </div>

      <div class="row grid">
        <div>
          <label>Viscosity <span class="val" id="viscVal">0.0002</span></label>
          <input id="visc" type="range" min="0" max="0.01" step="0.0001" value="0.0002">
        </div>
        <div>
          <label>Diffusion <span class="val" id="diffVal">0.0001</span></label>
          <input id="diff" type="range" min="0" max="0.01" step="0.0001" value="0.0001">
        </div>
      </div>

      <div class="row grid">
        <div>
          <label>Time Step <span class="val" id="dtVal">0.016</span></label>
          <input id="dt" type="range" min="0.005" max="0.033" step="0.001" value="0.016">
        </div>
        <div>
          <label>Vorticity <span class="val" id="vortVal">15</span></label>
          <input id="vort" type="range" min="0" max="40" step="1" value="15">
        </div>
      </div>

      <div class="row grid">
        <div>
          <label>Brush Size <span class="val" id="brushVal">10</span></label>
          <input id="brush" type="range" min="1" max="80" step="1" value="10">
        </div>
        <div>
          <label>Force <span class="val" id="forceVal">900</span></label>
          <input id="force" type="range" min="10" max="2000" step="10" value="900">
        </div>
      </div>

      <div class="row grid">
        <div>
          <label>Gravity Y <span class="val" id="gyVal">0</span></label>
          <input id="gy" type="range" min="-200" max="200" step="1" value="0">
        </div>
        <div>
          <label>Smoke Buoyancy <span class="val" id="buoyVal">0.1</span></label>
          <input id="buoy" type="range" min="0" max="1" step="0.01" value="0.1">
        </div>
      </div>

      <div class="row">
        <label>Ink Color</label>
        <div class="group">
          <input id="ink" type="color" value="#66ccff">
          <button id="rainbow">Cycle üé†</button>
        </div>
      </div>

      <div class="row grid">
        <div class="toggle"><input id="confToggle" type="checkbox" checked><span>Vorticity Confinement</span></div>
        <div class="toggle"><input id="advectMAC" type="checkbox" checked><span>MacCormack Advection</span></div>
      </div>

      <div class="row grid">
        <div class="toggle"><input id="edges" type="checkbox"><span>Wrap Edges</span></div>
        <div class="toggle"><input id="pretty" type="checkbox" checked><span>Pretty Additives ‚ú®</span></div>
      </div>

      <div class="row">
        <label>Color Cycle Speed <span class="val" id="colorSpeedVal">240</span></label>
        <input id="colorSpeed" type="range" min="0" max="1440" step="10" value="240">
      </div>

      <div class="row">
        <label>Presets</label>
        <div class="preset">
          <button data-preset="calm">Calm Pool</button>
          <button data-preset="storm">Stormy</button>
          <button data-preset="smoke">Smoky Room</button>
          <button data-preset="nebula">Nebula</button>
          <button data-preset="inkdrop">Ink Drop</button>
          <button data-preset="psyche">Psychedelia üå™Ô∏è</button>
        </div>
      </div>

      <div class="row grid">
        <button id="clear">Clear</button>
        <button id="pause">Pause ‚ñå‚ñå</button>
      </div>

      <div id="footer">
        WASD / ‚Üê‚Üë‚Üí‚Üì swirl; Shift = big brush; Alt/Right-click = suction. <br>
        Algorithm: semi-Lagrangian Stable Fluids (Stam) w/ projection, optional MacCormack, vorticity confinement, buoyancy. GPU-free.
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="c"></canvas>
      <div id="hud">FPS: <span id="fps">0</span> | Dye: RGB | Vel Projection | Advection: <span id="adv">MacCormack</span></div>
    </div>
  </div>

  <script>
    // ============================
    // Utility helpers
    // ============================
    const clamp=(x,a,b)=>x<a?a:(x>b?b:x);
    const lerp=(a,b,t)=>a+(b-a)*t;

    // Color cycling controls ‚Äî bumped way up by default
    let hue=200; let hueVel=240; // degrees per second-ish (scaled by dt)

    // ============================
    // Fluid grid (scalar & vector fields)
    // ============================
    class Fluid {
      constructor(n, wrap=false){
        this.setResolution(n, wrap);
        this.diff=1e-4; this.visc=2e-4; this.dt=0.016; this.vort=15; this.confine=true; this.buoy=0.1;
        this.advectMac=true; this.gravY=0; this.pretty=true;
      }
      setResolution(n, wrap){
        this.n = n|0; // square grid n x n
        this.wrap = !!wrap;
        const N=this.n; const size=(N+2)*(N+2);
        // Velocity fields u,v and temp arrays
        this.u=new Float32Array(size); this.v=new Float32Array(size);
        this.u0=new Float32Array(size); this.v0=new Float32Array(size);
        // Dye fields (RGB)
        this.r=new Float32Array(size); this.g=new Float32Array(size); this.b=new Float32Array(size);
        this.r0=new Float32Array(size); this.g0=new Float32Array(size); this.b0=new Float32Array(size);
        this.tmp=new Float32Array(size);
      }
      IX(x,y){ return x + (this.n+2)*y; }

      addSource(x, s, dt){ for(let i=0;i<x.length;i++) x[i]+=dt*s[i]; }

      setBnd(b, x){
        const N=this.n;
        for(let i=1;i<=N;i++){
          x[this.IX(0,i)]   = this.wrap? x[this.IX(N,i)]   : (b===1? -x[this.IX(1,i)]  : x[this.IX(1,i)]);
          x[this.IX(N+1,i)] = this.wrap? x[this.IX(1,i)]   : (b===1? -x[this.IX(N,i)]  : x[this.IX(N,i)]);
          x[this.IX(i,0)]   = this.wrap? x[this.IX(i,N)]   : (b===2? -x[this.IX(i,1)]  : x[this.IX(i,1)]);
          x[this.IX(i,N+1)] = this.wrap? x[this.IX(i,1)]   : (b===2? -x[this.IX(i,N)]  : x[this.IX(i,N)]);
        }
        x[this.IX(0,0)]       = 0.5*(x[this.IX(1,0)]     + x[this.IX(0,1)]);
        x[this.IX(0,N+1)]     = 0.5*(x[this.IX(1,N+1)]   + x[this.IX(0,N)]);
        x[this.IX(N+1,0)]     = 0.5*(x[this.IX(N,0)]     + x[this.IX(N+1,1)]);
        x[this.IX(N+1,N+1)]   = 0.5*(x[this.IX(N,N+1)]   + x[this.IX(N+1,N)]);
      }

      linSolve(b, x, x0, a, c){
        const N=this.n; const cRecip=1.0/c;
        for(let k=0;k<20;k++){
          for(let i=1;i<=N;i++){
            for(let j=1;j<=N;j++){
              x[this.IX(i,j)] = (x0[this.IX(i,j)] + a*(
                x[this.IX(i-1,j)] + x[this.IX(i+1,j)] + x[this.IX(i,j-1)] + x[this.IX(i,j+1)]
              ))*cRecip;
            }
          }
          this.setBnd(b,x);
        }
      }

      diffuse(b, x, x0, diff, dt){
        const N=this.n; const a = dt*diff*N*N;
        this.linSolve(b, x, x0, a, 1+4*a);
      }

      advect(b, d, d0, u, v, dt){
        const N=this.n; const dt0 = dt*N;
        for(let i=1;i<=N;i++){
          for(let j=1;j<=N;j++){
            let x = i - dt0 * u[this.IX(i,j)];
            let y = j - dt0 * v[this.IX(i,j)];
            if(this.wrap){
              while(x<0.5) x+=N; while(x>N+0.5) x-=N;
              while(y<0.5) y+=N; while(y>N+0.5) y-=N;
            } else {
              if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5;
              if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5;
            }
            const i0=Math.floor(x), i1=i0+1; const j0=Math.floor(y), j1=j0+1;
            const s1=x-i0, s0=1-s1; const t1=y-j0, t0=1-t1;
            d[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);
          }
        }
        this.setBnd(b,d);
      }

      // Simple MacCormack advection (predictor-corrector) for less diffusion
      advectMacCormack(b, d, d0, u, v, dt){
        const N=this.n; const dt0=dt*N;
        const phiHat=this.tmp; // reuse temp
        // Forward (predict)
        for(let i=1;i<=N;i++){
          for(let j=1;j<=N;j++){
            let x = i - dt0 * u[this.IX(i,j)];
            let y = j - dt0 * v[this.IX(i,j)];
            if(this.wrap){
              while(x<0.5) x+=N; while(x>N+0.5) x-=N;
              while(y<0.5) y+=N; while(y>N+0.5) y-=N;
            } else {
              if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5;
              if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5;
            }
            const i0=Math.floor(x), i1=i0+1; const j0=Math.floor(y), j1=j0+1;
            const s1=x-i0, s0=1-s1; const t1=y-j0, t0=1-t1;
            phiHat[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);
          }
        }
        this.setBnd(b,phiHat);
        // Backward (correct)
        for(let i=1;i<=N;i++){
          for(let j=1;j<=N;j++){
            let x = i + dt0 * u[this.IX(i,j)];
            let y = j + dt0 * v[this.IX(i,j)];
            if(this.wrap){
              while(x<0.5) x+=N; while(x>N+0.5) x-=N;
              while(y<0.5) y+=N; while(y>N+0.5) y-=N;
            } else {
              if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5;
              if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5;
            }
            const i0=Math.floor(x), i1=i0+1; const j0=Math.floor(y), j1=j0+1;
            const s1=x-i0, s0=1-s1; const t1=y-j0, t0=1-t1;
            const phiBar = s0*(t0*phiHat[this.IX(i0,j0)] + t1*phiHat[this.IX(i0,j1)]) + s1*(t0*phiHat[this.IX(i1,j0)] + t1*phiHat[this.IX(i1,j1)]);
            // Correct and clamp to prevent overshoot
            let corr = 0.5*(d0[this.IX(i,j)] - phiBar);
            d[this.IX(i,j)] = clamp(phiHat[this.IX(i,j)] + corr, Math.min(d0[this.IX(i,j)], phiHat[this.IX(i,j)]), Math.max(d0[this.IX(i,j)], phiHat[this.IX(i,j)]));
          }
        }
        this.setBnd(b,d);
      }

      project(u, v, p, div){
        const N=this.n; const IX=this.IX.bind(this);
        for(let i=1;i<=N;i++){
          for(let j=1;j<=N;j++){
            div[IX(i,j)] = -0.5*( u[IX(i+1,j)]-u[IX(i-1,j)] + v[IX(i,j+1)]-v[IX(i,j-1)] )/N;
            p[IX(i,j)] = 0;
          }
        }
        this.setBnd(0,div); this.setBnd(0,p);
        this.linSolve(0,p,div,1,4);
        for(let i=1;i<=N;i++){
          for(let j=1;j<=N;j++){
            u[IX(i,j)] -= 0.5*N*(p[IX(i+1,j)]-p[IX(i-1,j)]);
            v[IX(i,j)] -= 0.5*N*(p[IX(i,j+1)]-p[IX(i,j-1)]);
          }
        }
        this.setBnd(1,u); this.setBnd(2,v);
      }

      vorticityConfinement(u,v,eps){
        const N=this.n; const IX=this.IX.bind(this);
        // Compute vorticity w = dvy/dx - dux/dy
        for(let i=2;i<=N-1;i++){
          for(let j=2;j<=N-1;j++){
            const dw_dx = (Math.abs(v[IX(i+1,j)] - v[IX(i-1,j)])*0.5);
            const dw_dy = (Math.abs(u[IX(i,j+1)] - u[IX(i,j-1)])*0.5);
            const len = Math.sqrt(dw_dx*dw_dx + dw_dy*dw_dy) + 1e-6;
            const Nx = dw_dx/len, Ny = dw_dy/len; // gradient of |curl|
            const w = (v[IX(i+1,j)] - v[IX(i-1,j)] - (u[IX(i,j+1)] - u[IX(i,j-1)]))*0.5;
            // Force perpendicular to gradient, scaled by epsilon
            this.u[IX(i,j)] += eps * (Ny * w);
            this.v[IX(i,j)] += eps * (-Nx * w);
          }
        }
        this.setBnd(1,this.u); this.setBnd(2,this.v);
      }

      step(){
        const N=this.n, dt=this.dt;
        const u=this.u,v=this.v,u0=this.u0,v0=this.v0; const r=this.r,g=this.g,b=this.b, r0=this.r0, g0=this.g0, b0=this.b0;

        // Apply gravity/buoyancy
        if(this.gravY!==0){ for(let i=0;i<u.length;i++) v[i] += this.gravY*dt/N; }
        if(this.buoy>0){
          for(let i=0;i<r.length;i++){
            const density = (r[i]+g[i]+b[i])*(1/3); // grayscale density
            v[i] += -this.buoy*density*dt; // lighter rises (negative pulls up)
          }
        }

        // Diffuse velocity
        this.diffuse(1, u0, u, this.visc, dt);
        this.diffuse(2, v0, v, this.visc, dt);
        // Project to make incompressible
        this.project(u0,v0,u,v);
        // Advect velocity
        if(this.advectMac) { this.advectMacCormack(1,u,u0,u0,v0,dt); this.advectMacCormack(2,v,v0,u0,v0,dt); }
        else { this.advect(1,u,u0,u0,v0,dt); this.advect(2,v,v0,u0,v0,dt); }
        // Project again
        this.project(u,v,u0,v0);

        // Optional confinement for curls
        if(this.confine && this.vort>0){ this.vorticityConfinement(u,v,this.vort*dt*0.0015); }

        // Diffuse dye
        this.diffuse(0, r0, r, this.diff, dt);
        this.diffuse(0, g0, g, this.diff, dt);
        this.diffuse(0, b0, b, this.diff, dt);
        // Advect dye
        if(this.advectMac){
          this.advectMacCormack(0,r,r0,u,v,dt);
          this.advectMacCormack(0,g,g0,u,v,dt);
          this.advectMacCormack(0,b,b0,u,v,dt);
        } else {
          this.advect(0,r,r0,u,v,dt);
          this.advect(0,g,g0,u,v,dt);
          this.advect(0,b,b0,u,v,dt);
        }

        // Decay a tiny bit to prevent saturation
        const decay=0.9995; for(let i=0;i<r.length;i++){ r[i]*=decay; g[i]*=decay; b[i]*=decay; }

        // Clear sources (we accumulate externally each frame)
        u0.fill(0); v0.fill(0); r0.fill(0); g0.fill(0); b0.fill(0);
      }
    }

    // ============================
    // Rendering
    // ============================
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('2d'); // 2D canvas renderer (CPU-side sim)

    function resizeCanvas(){
      const dpr = Math.min(2, window.devicePixelRatio||1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
    }

    // Color mapping helper
    function rgb(r,g,b){ return `rgb(${(r*255)|0},${(g*255)|0},${(b*255)|0})`; }

    // ============================
    // App state & UI wiring
    // ============================
    const fluid = new Fluid(128);

    const el = id=>document.getElementById(id);
    const n = el('n'), visc=el('visc'), diff=el('diff'), dt=el('dt'), vort=el('vort');
    const brush=el('brush'), force=el('force'), gy=el('gy'), buoy=el('buoy');
    const ink=el('ink'); const confToggle=el('confToggle'); const advectMAC=el('advectMAC');
    const edges=el('edges'); const pretty=el('pretty');
    const clearBtn=el('clear'); const pauseBtn=el('pause'); const rainbow=el('rainbow');
    const colorSpeed=el('colorSpeed'); const colorSpeedVal=el('colorSpeedVal');

    const nDisplay=el('nDisplay'), nDisplayY=el('nDisplayY');
    const viscVal=el('viscVal'), diffVal=el('diffVal'), dtVal=el('dtVal'), vortVal=el('vortVal');
    const brushVal=el('brushVal'), forceVal=el('forceVal'), gyVal=el('gyVal'), buoyVal=el('buoyVal');
    const fpsEl=el('fps'); const advEl=el('adv');

    function syncLabels(){
      nDisplay.textContent = fluid.n; nDisplayY.textContent=fluid.n;
      viscVal.textContent = (+visc.value).toFixed(4);
      diffVal.textContent = (+diff.value).toFixed(4);
      dtVal.textContent = (+dt.value).toFixed(3);
      vortVal.textContent = (+vort.value).toString();
      brushVal.textContent = brush.value; forceVal.textContent=force.value; gyVal.textContent=gy.value; buoyVal.textContent=(+buoy.value).toFixed(2);
      advEl.textContent = advectMAC.checked? 'MacCormack':'Semi-Lagrangian';
      colorSpeedVal.textContent = (+colorSpeed.value).toString();
    }

    function applyUI(){
      fluid.visc = +visc.value; fluid.diff = +diff.value; fluid.dt = +dt.value; fluid.vort=+vort.value;
      fluid.confine = confToggle.checked; fluid.advectMac = advectMAC.checked; fluid.wrap = edges.checked; fluid.buoy=+buoy.value; fluid.gravY=+gy.value/1000;
      hueVel = +colorSpeed.value; // üî• faster cycling via slider
      syncLabels();
    }

    [visc,diff,dt,vort,brush,force,gy,buoy,confToggle,advectMAC,edges,pretty,colorSpeed].forEach(x=>x.addEventListener('input', applyUI));

    n.addEventListener('change', ()=>{ fluid.setResolution(+n.value, edges.checked); syncLabels(); });

    clearBtn.addEventListener('click', ()=>{ fluid.u.fill(0); fluid.v.fill(0); fluid.r.fill(0); fluid.g.fill(0); fluid.b.fill(0); });

    let paused=false; pauseBtn.addEventListener('click', ()=>{ paused=!paused; pauseBtn.textContent = paused? 'Resume ‚ñ∂':'Pause ‚ñå‚ñå'; });

    rainbow.addEventListener('click', ()=>{ const sign = Math.random()<.5?-1:1; hueVel = (Math.random()*720+120)*sign; colorSpeed.value = Math.abs(hueVel); syncLabels(); });

    // Presets
    document.querySelectorAll('.preset button').forEach(btn=>btn.addEventListener('click',()=>{
      const p=btn.dataset.preset; if(p==='calm'){
        visc.value=0.002; diff.value=0.0005; vort.value=4; dt.value=0.02; gy.value=0; buoy.value=0.02; advectMAC.checked=true; edges.checked=false; pretty.checked=false; colorSpeed.value=60;
      } else if(p==='storm'){
        visc.value=0.0002; diff.value=0.0002; vort.value=30; dt.value=0.015; gy.value=0; buoy.value=0.12; advectMAC.checked=true; edges.checked=false; pretty.checked=true; colorSpeed.value=240;
      } else if(p==='smoke'){
        visc.value=0.001; diff.value=0.0008; vort.value=18; dt.value=0.02; gy.value=-60; buoy.value=0.4; advectMAC.checked=true; edges.checked=false; pretty.checked=false; colorSpeed.value=30;
      } else if(p==='nebula'){
        visc.value=0.0001; diff.value=0.0004; vort.value=26; dt.value=0.018; gy.value=0; buoy.value=0.0; advectMAC.checked=true; edges.checked=true; pretty.checked=true; colorSpeed.value=360;
      } else if(p==='inkdrop'){
        visc.value=0.0008; diff.value=0.0005; vort.value=9; dt.value=0.018; gy.value=90; buoy.value=0.15; advectMAC.checked=false; edges.checked=false; pretty.checked=false; colorSpeed.value=120;
      } else if(p==='psyche'){
        visc.value=0.0002; diff.value=0.0003; vort.value=34; dt.value=0.016; gy.value=0; buoy.value=0.0; advectMAC.checked=true; edges.checked=true; pretty.checked=true; colorSpeed.value=720; // üí• max rainbow
      }
      applyUI();
    }));

    // ============================
    // Interaction
    // ============================
    const mouse={x:0,y:0, px:0,py:0, down:false, alt:false};
    const canvasEl=document.getElementById('c');
    canvasEl.addEventListener('contextmenu',e=>e.preventDefault());
    window.addEventListener('pointerdown',e=>{ mouse.down=true; mouse.alt = e.button===2 || e.altKey; updateMouse(e); });
    window.addEventListener('pointerup',()=>{ mouse.down=false; });
    window.addEventListener('pointermove',updateMouse);
    window.addEventListener('keydown',e=>{ if(['Space'].includes(e.code)) { paused=!paused; pauseBtn.textContent = paused? 'Resume ‚ñ∂':'Pause ‚ñå‚ñå'; } });

    function updateMouse(e){
      const rect=canvasEl.getBoundingClientRect();
      const dpr=Math.min(2, window.devicePixelRatio||1);
      mouse.px=mouse.x; mouse.py=mouse.y;
      mouse.x = ((e.clientX - rect.left)/rect.width) * (fluid.n+2);
      mouse.y = ((e.clientY - rect.top)/rect.height) * (fluid.n+2);
      mouse.alt = e.buttons===2 || e.altKey;
      if(mouse.down) paint();
    }

    function paint(){
      const N=fluid.n; const IX=fluid.IX.bind(fluid);
      const r=fluid.r0, g=fluid.g0, b=fluid.b0, u=fluid.u0, v=fluid.v0;
      const bs = ( +brush.value ) * (window.event && window.event.shiftKey ? 2.5 : 1 );

      // Velocity from mouse delta
      const dx = (mouse.x - mouse.px) * (+force.value)/500;
      const dy = (mouse.y - mouse.py) * (+force.value)/500;

      // Color
      let inkColor = hexToRgb(ink.value);
      if(pretty.checked){
        hue = (hue + hueVel*fluid.dt) % 360;
        const c = hsl2rgb(hue/360, 0.75, 0.55);
        inkColor = {r:c[0]*255, g:c[1]*255, b:c[2]*255};
      }

      for(let i=-bs;i<=bs;i++){
        for(let j=-bs;j<=bs;j++){
          const x=(mouse.x|0)+i, y=(mouse.y|0)+j; if(x<1||y<1||x>N||y>N) continue;
          const w = 1 - Math.hypot(i,j)/bs; if(w<=0) continue;
          const idx = IX(x,y);
          const mul = mouse.alt? -0.6 : 1.0;
          u[idx] += dx * w * mul; v[idx] += dy * w * mul;
          r[idx] += (inkColor.r/255) * w * 1.1;
          g[idx] += (inkColor.g/255) * w * 1.1;
          b[idx] += (inkColor.b/255) * w * 1.1;
        }
      }
    }

    function hexToRgb(hex){
      const bigint=parseInt(hex.slice(1),16); return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 };
    }
    function hsl2rgb(h,s,l){
      const a=s*Math.min(l,1-l);
      const f=n=>{const k=(n+h*12)%12; return l-a*Math.max(-1,Math.min(k-3,9-k,1));};
      return [f(0),f(8),f(4)];
    }

    // ============================
    // Draw dye to canvas
    // ============================
    function render(){
      const N=fluid.n; const IX=fluid.IX.bind(fluid);
      const dpr = Math.min(2, window.devicePixelRatio||1);
      const cw = canvasEl.width, ch = canvasEl.height;
      const cellX = cw/(N+2), cellY=ch/(N+2);
      gl.clearRect(0,0,cw,ch);
      const r=fluid.r,g=fluid.g,b=fluid.b;
      for(let i=1;i<=N;i++){
        for(let j=1;j<=N;j++){
          const rr=r[IX(i,j)], gg=g[IX(i,j)], bb=b[IX(i,j)];
          if(rr+gg+bb<1e-4) continue;
          gl.fillStyle = rgb(rr,gg,bb);
          gl.fillRect((i-0.5)*cellX, (j-0.5)*cellY, cellX+1, cellY+1);
        }
      }
    }

    // ============================
    // Main loop
    // ============================
    let last=performance.now(), frames=0, fps=0, fpsT=0;
    function loop(ts){
      const dtReal = (ts-last)/1000; last=ts; fpsT+=dtReal; frames++; if(fpsT>0.5){ fps = Math.round(frames/fpsT*2)/2; fpsEl.textContent=fps; frames=0; fpsT=0; }
      if(!paused){
        fluid.addSource(fluid.u, fluid.u0, 1);
        fluid.addSource(fluid.v, fluid.v0, 1);
        fluid.addSource(fluid.r, fluid.r0, 1);
        fluid.addSource(fluid.g, fluid.g0, 1);
        fluid.addSource(fluid.b, fluid.b0, 1);
        fluid.step();
      }
      render();
      requestAnimationFrame(loop);
    }

    const ro = new ResizeObserver(()=>{ resizeCanvas(); });
    ro.observe(document.getElementById('canvasWrap'));
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    applyUI(); syncLabels();
    requestAnimationFrame(loop);

    // Intro burst for vibes ‚Äî now faster color cycling out of the gate
    function intro(){
      const w=canvasEl.clientWidth, h=canvasEl.clientHeight;
      const evt = { clientX:w*0.5, clientY:h*0.5 };
      const old = hueVel; hueVel = Math.max(360, hueVel); // ensure fast spin on start
      mouse.down=true; updateMouse(evt);
      for(let k=0;k<10;k++){ hue=(k*36)%360; paint(); mouse.px=mouse.x; mouse.py=mouse.y; mouse.x+=Math.cos(k)*6; mouse.y+=Math.sin(k)*6; }
      mouse.down=false; render();
      hueVel = old; // restore slider choice
    }
    setTimeout(intro, 60);

    // Keyboard swirl
    const keys=new Set();
    window.addEventListener('keydown',e=>{ keys.add(e.key.toLowerCase()); });
    window.addEventListener('keyup',e=>{ keys.delete(e.key.toLowerCase()); });
    setInterval(()=>{
      const u0=fluid.u0, v0=fluid.v0; const N=fluid.n; const IX=fluid.IX.bind(fluid);
      let fx=0, fy=0; if(keys.has('a')||keys.has('arrowleft')) fx+=0.7; if(keys.has('d')||keys.has('arrowright')) fx-=0.7; if(keys.has('w')||keys.has('arrowup')) fy+=0.7; if(keys.has('s')||keys.has('arrowdown')) fy-=0.7;
      if(fx||fy){ for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ const idx=IX(i,j); u0[idx]+=fx*0.2; v0[idx]+=fy*0.2; } } }
    }, 50);

    // ============================
    // Minimal self-tests (dev only)
    // ============================
    (function selfTest(){
      try{
        console.assert(!!document.getElementById('c'), '[self-test] canvas element missing');
        console.assert(typeof mouse === 'object' && mouse !== null, '[self-test] mouse state missing');
        console.assert(typeof fluid.step === 'function', '[self-test] fluid.step missing');
        console.log('[self-test] basic checks passed');
      }catch(e){
        console.warn('[self-test] failed', e);
      }
    })();
  </script>
</body>
</html>
